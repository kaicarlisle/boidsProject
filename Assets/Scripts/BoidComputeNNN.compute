// N nearest neighbours model

#pragma kernel CSMain
static const int threadGroupSize = 1024;

struct Boid {
    float2 position;
    float2 direction;

    float2 flockHeading;
    float2 flockCentre;
    float2 separationHeading;
    int numFlockmates;
};

RWStructuredBuffer<Boid> boids;
uint numBoids;
uint screenWidth;
uint screenHeight;
uint maxNumNeighbours;

// not used
float viewRadius;
float avoidRadius;
float minFov;
float maxFov;

// local variables
uint numNeighbours;
float viewRadiusSqrd;

[numthreads(threadGroupSize,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	// calculate the viewRadius to use to get maxNumNeighbours neighbours
	numNeighbours = 0;
	viewRadius = 0.5;
	avoidRadius = 0.1;
	while (numNeighbours <= maxNumNeighbours) {
		numNeighbours = 0;
		for (uint indexB = 0; indexB < numBoids; indexB ++) {
			if (id.x != indexB) {
				Boid boidB = boids[indexB];
				float2 offset = boidB.position - boids[id.x].position;
				float sqrDst = offset.x * offset.x + offset.y * offset.y;

				if (sqrDst < viewRadius * viewRadius) {
					numNeighbours += 1;
					continue;
				}
				
				float2 offset1 = offset + screenHeight;
				float2 offset2 = offset + screenWidth + screenHeight;
				float2 offset3 = offset + screenWidth;
				float2 offset4 = offset + screenWidth - screenHeight;
				float2 offset5 = offset - screenHeight;
				float2 offset6 = offset - screenHeight - screenWidth;
				float2 offset7 = offset - screenWidth;
				float2 offset8 = offset - screenWidth + screenHeight;
				
				float sqrDst1 = offset1.x * offset1.x + offset1.y * offset1.y;
				float sqrDst2 = offset2.x * offset1.x + offset1.y * offset1.y;
				float sqrDst3 = offset3.x * offset3.x + offset3.y * offset3.y;
				float sqrDst4 = offset4.x * offset4.x + offset4.y * offset4.y;
				float sqrDst5 = offset5.x * offset5.x + offset5.y * offset5.y;
				float sqrDst6 = offset6.x * offset6.x + offset6.y * offset6.y;
				float sqrDst7 = offset7.x * offset7.x + offset7.y * offset7.y;
				float sqrDst8 = offset8.x * offset8.x + offset8.y * offset8.y;
				
				viewRadiusSqrd = viewRadius * viewRadius;
				
				if (sqrDst1 < viewRadiusSqrd ||
					sqrDst2 < viewRadiusSqrd ||
					sqrDst3 < viewRadiusSqrd ||
					sqrDst4 < viewRadiusSqrd ||
					sqrDst5 < viewRadiusSqrd ||
					sqrDst6 < viewRadiusSqrd ||
					sqrDst7 < viewRadiusSqrd ||
					sqrDst8 < viewRadiusSqrd) {
					numNeighbours += 1;
					continue;
				}
			}
		}
		viewRadius += 0.2;
		avoidRadius += 0.05;
	}
	
	// get the maxNumNeighbours nearest neighbours
	for (uint indexB = 0; indexB < numBoids; indexB ++) {
		if (id.x != indexB) {
			Boid boidB = boids[indexB];
			float2 offset = boidB.position - boids[id.x].position;
			float sqrDst = offset.x * offset.x + offset.y * offset.y;

			if (sqrDst < viewRadius * viewRadius) {
				boids[id.x].numFlockmates += 1;
				boids[id.x].flockHeading += boidB.direction;
				boids[id.x].flockCentre += boidB.position;

				if (sqrDst < avoidRadius * avoidRadius) {
					boids[id.x].separationHeading -= offset / sqrDst;
				}
				continue;
			}
			
			float2 offset1 = offset + screenHeight;
			float2 offset2 = offset + screenWidth + screenHeight;
			float2 offset3 = offset + screenWidth;
			float2 offset4 = offset + screenWidth - screenHeight;
			float2 offset5 = offset - screenHeight;
			float2 offset6 = offset - screenHeight - screenWidth;
			float2 offset7 = offset - screenWidth;
			float2 offset8 = offset - screenWidth + screenHeight;
			
			float sqrDst1 = offset1.x * offset1.x + offset1.y * offset1.y;
			float sqrDst2 = offset2.x * offset1.x + offset1.y * offset1.y;
			float sqrDst3 = offset3.x * offset3.x + offset3.y * offset3.y;
			float sqrDst4 = offset4.x * offset4.x + offset4.y * offset4.y;
			float sqrDst5 = offset5.x * offset5.x + offset5.y * offset5.y;
			float sqrDst6 = offset6.x * offset6.x + offset6.y * offset6.y;
			float sqrDst7 = offset7.x * offset7.x + offset7.y * offset7.y;
			float sqrDst8 = offset8.x * offset8.x + offset8.y * offset8.y;
			
			viewRadiusSqrd = viewRadius * viewRadius;
			
			if (sqrDst1 < viewRadiusSqrd ||
				sqrDst2 < viewRadiusSqrd ||
				sqrDst3 < viewRadiusSqrd ||
				sqrDst4 < viewRadiusSqrd ||
				sqrDst5 < viewRadiusSqrd ||
				sqrDst6 < viewRadiusSqrd ||
				sqrDst7 < viewRadiusSqrd ||
				sqrDst8 < viewRadiusSqrd) {
				boids[id.x].numFlockmates += 1;
				boids[id.x].flockHeading += boidB.direction;
				boids[id.x].flockCentre += boidB.position;

				if (sqrDst < avoidRadius * avoidRadius) {
					boids[id.x].separationHeading -= offset / sqrDst;
				}
				continue;
			}
		}
	}
}